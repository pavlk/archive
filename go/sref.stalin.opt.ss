; GTP Go bot for Stalin Scheme

(define (version) "2010.06.29") 
(define L (if (>= (:l argv) 2) (s2n (: argv 1)) 100))
(define N 9) ; boardsize
(define K 7) ; komi

; PRELUDE: INCLUDES & UTILITIES & MACROS
(include "QobiScheme") 
(define ABC "ABCDEFGHIJKLMNOPQRSTUVWXYZ") (define (& x y) (bitwise-and x y)) (define (xI x y) (bitwise-xor x y))
(define := make-vector) (define :! vector-set!) (define : vector-ref) (define :> vector-copy) (define (oI x y) (bitwise-or x y)) 
(define (::! V1 V2) (do ((i 0 (+ i 1))) ((= i (:l V2)) V2) (:! V2 i (: V1 i )))) (define (:++ s i) (:! s i (+ 1 (: s i))))
(define (vector-drop n V) (let ((V2 (:= (- (:l V) n)))) (do ((i 0 (+ i 1))) ((= i (:l V2)) V2) (:! V2 i (: V (+ i n) )))))
(define (:c f V) (let ((c 0)) (do ((i 0 (+ i 1))) ((= i (:l V)) c) (when (f (: V i)) (set! c (+ c 1))))))
(define (:i! V) (do ((i 0 (+ i 1))) ((= i (:l V))) (:! V i 0)))
(define (:for-each f V) (do ((i 0 (+ i 1))) ((= i (:l V))) (f (: V i))))
(define (:for-v-i f V) (do ((i 0 (+ i 1))) ((= i (:l V))) (f (: V i) i)))
(define (:for-n f V n) (do ((i 0 (+ i 1))) ((= i n)) (f (: V i))))
(define (:foldl f init V) (do ((i 0 (+ i 1))) ((= i (:l V)) init) (set! init (f init (: V i)))))
(define (foldl f init l) (if (null? l) init (f (car l) (foldl f init (cdr l)))))
(define (:/ V1 V2) (let ((V (:> V1))) (do ((j 0 (+ j 1))) ((= j (:l V)) V) (:! V j (/ (: V1 j) (: V2 j))))))
(define (:max V) (let ((i 0) (o -99999)) (do ((j 0 (+ j 1))) ((= j (:l V)) i) (when (> (: V j) o) (set! i j) (set! o (: V j))))))
(define s2n string->number) (define n2s number->string) (define app string-append) (define :l vector-length) 
(define (iota n) (do ((n n (- n 1)) (list '() (cons (- n 1) list))) ((zero? n) list)))
(define (string-ind str c) (let lp ((i (string-length str))) (and (<= 0 i) (if (char=? c (string-ref str i)) i (lp (- i 1))))))
(define (string-tokenize str) (str-split str #\space))
(define (str-split str ch) (let ((len (string-length str)))
			     (letrec ((split (lambda (a b) 
					       (cond ((>= b len) (if (= a b) '() (cons (substring str a b) '())))
						     ((char=? ch (string-ref str b)) (if (= a b)
											 (split (+ 1 a) (+ 1 b))
											 (cons (substring str a b) (split b b))))
						     (else (split a (+ 1 b)))))))
			       (split 0 0))))
(define (rember* l r) 
  (let rloop ((r r)) (cond ((equal? `() r) r)
			   (else (let ((first-r (car r)))
				   (let loop ((l-rest l)) (cond ((equal? `() l-rest) (cons first-r (rloop (cdr r))))
								((equal? (car l-rest) first-r) (rloop (cdr r)))
								(else (loop (cdr l-rest))))))))))
(define (lookup var env) (if (pair? (assoc var env)) (cdr (assoc var env)) (lambda () (display "? unknown command"))))
(define (rm-comment s) (let ((i (string-ind s #\#))) (if i (substring s 0 i) s)))
(define (rm-bad-chars-bu str) (list->string (string->list str))) 
(define (rm-bad-chars str) (list->string  (rember* (map integer->char (rember* '(0 9 10) (iota 32)))  (string->list str))))
(define (rgtp) (string-tokenize (rm-bad-chars (rm-comment (read-line)))))
(define (s2m s) (if (or (equal? s "pass") (equal? s "resign")) 
		    0 
		    (p (- N (s2n (string (string-ref s 1)))) (string-ind ABC (string-ref s 0)))))
(define (p2s p) (if (= p 0) "." (if (= p 1) "O" "#")))
(define (m2s m) (cond ((= m 0)  "pass") 
		      ((> m 0) (app (string (string-ref ABC (- (inexact->exact (modulo m N1)) 1)))
				    (number->string (- N (- (floor (inexact->exact (/ m N1))) 1)))))
		      (else "error move")))

; GTP INTERFACE
(define CMDS `((,"quit" . 0) (,"name" . ,name) (,"version" . ,version) (,"protocol_version" . ,protocol_version) 
	       (,"komi" . ,komi) (,"known_command" . ,known_command) (,"list_commands" . ,list_commands) 
	       (,"boardsize" . ,boardsize) (,"clear_board" . ,clear_board) (,"showboard" . ,showboard) 
	       (,"genmove" . ,genmove) (,"play" . ,play) (,"s2m" . ,s2m) (,"g" . ,g) (,"s" . ,s) (,"final_score" . ,final_score)
	       (,"ref-playouts" . ,ref-playouts)  (,"ref-score" . ,ref-score)  (,"ref-nodes" . ,ref-nodes)))
(define (name) "SRef") 
(define (protocol_version) "2") 
(define (komi v) (begin (set! K (s2n v)) ""))
(define (known_command str) (if (member str (map car CMDS)) "true" "false"))
(define (list_commands) (foldl (lambda (s l) (app (format #f "~a~%" s) l)) "" (map car CMDS)))
(define (boardsize v) (begin (set! N (s2n v)) (clear_board) ""))
(define (clear_board)
  (set! NMS 0)   
  (do ((r 0 (+ r 1))) ((= r N)) (do ((c 0 (+ c 1))) ((= c N)) (:! BRD (p r c) 0))) 
  "")
(define (showboard) (let ((s "")) (do ((i 0 (+ i 1))) ((= i N) s) (set! s (app s (string #\newline)))
				      (do ((j 0 (+ j 1))) ((= j N)) (set! s (app s (app " " (p2s (: BRD (p i j))))))))))
(define (play c m) (let* ((mv (s2m m)) (res (make BRD NMS mv 0 #f))) (if (> 0 res) "illegal move" (begin (save-m HIS res mv) ""))))
(define (final_score) (let ((s (score BRD))) (if (= s 0) "0" (app (if (> s 0.0) "B+"  "W+") (n2s (abs s))))))  
(define (ref-playouts) (n2s L))
(define (ref-score) (n2s (+ 0.5 (* 0.5 (/ (G-score G) L)))))
(define (ref-nodes) (n2s (G-nodes G)))
(define (g) (genmove 'c)) (define (s) (showboard))

; INITIALIZE & LOOP
(define BRD (:= NNN 4)); (define HIS (:= (* 4 NNN) 0)) 
(define NMS 0) (define (NMS++) (begin (set! NMS (+ NMS 1)) (if (> NMS 0) (- NMS 1) 0)))
(define (save-m H res m)
  (when (>= res 0) (if (= res 0)
	    (:! H (NMS++) m)
	    (begin (if (= res 1) 
		       (:! H (NMS++) m) 
 		       (:! H (NMS++) m))))))
(define (init) (let ((i 0)) (set! BRD (:= NNN 4)) (set! HIS (:= (* 4 NNN) 0)) (clear_board)
		    (do ((r 0 (+ r 1))) ((= r N)) (do ((c 0 (+ c 1))) ((= c N)) (:! BRD (p r c) 0) (set! i (+ i 1))))))
(define (go) (do ((l (rgtp) (rgtp))) ((equal? l '("quit")) (display "= ") (newline) (newline)) 
  (display (app "= " (apply (lookup (car l) CMDS) (cdr l)))) (newline) (newline)))

(define seed 1) (define M (expt 2 20)) (define A 3412421) 
(define (random-n n) (set! seed (modulo (+ A (* seed A)) M)) (>> (* n (& seed #xFFFF)) 16))
; ---------------------------------------------------------------------------------------------------------------

(define (genmove nil) 
  (let ((m (mc L (::! HIS (:= NMS))))) 
    (if (equal? "" (play 'c  (m2s m))) 
	(m2s m) 
	"pass")))

; ---------------------------------------------------------------------------------------------------------------
(define-structure G B B2 ms c H WINS HITS nodes score) 
(define G 0) 

(define (init-G H) 
  (set-G-B2! G (H->B H (:l H) (:= NNN 4))) (set-G-ms! G (:l H)) (set-G-c! G 0)
  (:i! (G-WINS G)) (:i! (G-HITS G)) (set-G-nodes! G 0) (set-G-score! G 0))

(define (H->B H sz B) 
  (do ((i 0 (+ i 1))) ((= i NN)) 
    (:! B (: P i) 0)) 
  (do ((i 0 (+ i 1))) ((= i sz) B) 
    (make B i (: H i) 0 #f)))

(define N1 (+ N 1)) 
(define N2 (+ N 2)) 
(define NN (* N N)) 
(define NNN (+ 1 (* N1 N2))) 
(define vdir (vector 1 -1 N1 (- 0 N1))) 
(define vdia (vector N (- 0 N) N2 (- 0 N2)))
(define v4 (:= 4))
(define (p r c) (+ (* (+ r 1) N1) c 1)) 
(define P (:= NN 0)) 

(let ((i 0)) 
  (do ((r 0 (+ r 1))) ((= r N)) 
    (do ((c 0 (+ c 1))) ((= c N)) 
      ;(:! BRD (p r c) 0)
      (:! P i (p r c)) (set! i (+ i 1)))))

(define (fstone c) (- 2 (& c 1))) 
(define (estone c) (xI 3 (- 2 (& c 1))))
(define (for-nbrs m f) (:for-each (lambda (x) (f (+ m x))) vdir))  ; optim: predpocitat (neighb-inds m)

(define (edge? B m) ; optim: predratat
  (< 0 (:c (lambda (x) (= x 4)) (dia-neighbours B m)))) 

(define (nbrs m) (list (+ m (: vdir 0)) (+ m (: vdir 1)) (+ m (: vdir 2)) (+ m (: vdir 3))))

(define (neighbours B m) 
  (:for-v-i (lambda (d i) (:! v4 i (: B (+ m d)))) vdir)
  v4)

(define (dia-neighbours B m) 
  (:for-v-i (lambda (d i) (:! v4 i (: B (+ m d)))) vdia)
  v4)

(define (owner-color B m) 
  (if (= (: B m) 0) 
      (& 3 (:foldl oI 0 (neighbours B m))) 
      (: B m)))

(define (score B) 
  (let ((s (:= 3 0))) 
    (:for-each (lambda (m) (:++ s (owner-color B m))) P) 
    (- (: s 2) (: s 1) K)))

(define (norm-score s ms) 
  (cond ((= s 0) 0) 
	((xor (> s 0) (odd? ms)) 1) 
	(else -1)))

(define (nfriends B c m) 
  (:c (lambda (x) (or (= x 4) (= x (fstone c)))) 
      (neighbours B m)))

(define (ndia-enemies B c m) 
  (:c (lambda (x) (= x (estone c))) 
      (dia-neighbours B m)))

(define (eye? B c m) ; optim: nfriends -> any-enemies-or-epty? (ktora vyskoci akonahle najde) 
  (and (= 4 (nfriends B c m)) 
       (<= (ndia-enemies B c m) (if (edge? B m) 0 1)))) ; optim: predpocitat (edge? m)

(define (nsuperko? B H ms) 
  (do ((i 0 (+ i 1))) ((or (= i ms) 
			   (= (hsh B) (hsh (H->B H i (:= NNN 4))))) 
		       (= i ms))))

(define (hsh B) 
  (let ((k 5831)) 
    (do ((i 0 (+ i 1))) ((= i NNN) k) 
      (set! k (+ k (& (<< k 5) 1023) (: B i))))))

(define (legal? B H ms m) 
  (or (= m 0) 
      (and (not (eye? B ms m)) 
	   (<= 0 (make B ms m 0 #f)) 
	   (nsuperko? B H ms))))

(define MARKS (:= (+ 2 NN) 0))

(define (mark B i m) 
  (:! MARKS i m)
  (:! B m (oI 64 (: B m)))) ;optim: netreba, staci MARKS?

(define (unmark B top) 
  (:for-n (lambda (x) (:! B x (xI 64 (: B x)))) 
	  MARKS top))

(define (capture B t) 
  (let ((n (libs? B t))) 
    (:for-n (lambda (x) (:! B x 0)) MARKS n)
    n))

(define (libs B ms mrk) 
  (cond ((null? ms) mrk)
	((= 0 (: B (car ms))) 0)
	(else (libs (append (cdr ms) (nbrs (car ms))) ; todo - len vyskusat, tu bolo nespravne libs?
		     (if (member (car ms) mrk) 
			 mrk 
			 (begin (mark B (length mrk) (car ms))
				(cons (car ms) mrk)))))))

(define (libs?-todo B t) 
  (let ((l (libs B (list t) '()))) 
    (if (null? l) 0 (length l))))

(define (libs? B t) 
  (let ((top 1) (tcol (: B t)))
    (mark B 0 t) 
    (do ((j 0 (+ j 1))) ((>= j top) 
			 (unmark B top) 
			 (if (= j top) top 0))
      (for-nbrs (: MARKS j) (lambda (x) (if (= 0 (: B x)) 
					    (set! j 9999) 
					    (when (= tcol (: B x)) 
						  (mark B top x) 
						  (set! top (+ 1 top)))))))))

(define (make B ms m last_m ko) 
  (letrec ((cap 0))
    (cond ((= m 0) 0) ; pass
	  ((> (: B m) 0) -3) ; occupied
	  (else (begin (:! B m (fstone ms)) ; place stone
		       (let ((x 0)) (do ((d 0 (+ d 1))) ((= d 4)) 
				      (set! x (+ m (: vdir d)))
				      (when (= (estone ms) (: B x)) 
					    (set! cap (+ cap (capture B x))))))
		       ;(for-nbrs m (lambda (y) (when (= (estone ms) (: B y)) (set! cap (+ cap (capture B y))))))
		       (cond ((= 0 cap) (if (< 0 (libs? B m))      ; suicide? 
					    (begin (:! B m 0) 
						   -1)             ; takeback m
 					    cap))                  ; store m
			     ((= 1 cap) (if (and ko (= 0 (: B last_m)))
					    (begin (:! B last_m (estone ms)) 
						   (:! B m 0) 
						   -2) ; ko
					    cap))
			     (else cap)))))))

(define (playout G)  
  (let ((c (G-ms G)) (ms (G-ms G)) (B (G-B G)) (H (G-H G)) 
	(ko #f) (res 0) (top 0) (i 0) (r 0) (em 0) (m 0) (E (:= NN 0)))
    (define (get-empty) 
      (set! top 0)
      (do ((j 0 (+ j 1))) ((= j NN)) 
	(when (= 0 (: B (: P j))) (:! E top (: P j)) (set! top (+ top 1)))))
    (define (r-m) 
      (set! r (+ i (random-n (- top i)))) 
      (set! em (: E r)) (:! E r (: E i)) (:! E i em) em)
    (define (find-m) 
      (if (= i top) 
	  (begin (set! ko #f) 0) 
	  (let ((m (make-r-m (r-m)))) (set! i (+ i 1)) 
	       (if (>= m 0) m (find-m)))))   
    (define (make-r-m m)
      (let* ((o (if (eye? B c m) -4 (make B c m (: H (- c 1)) ko))))
	(cond ((< o 0) -1)
	      ((= o 0) (begin (set! ko #f) 
			      (set! top (- top 1)) 
			      (:! E i (: E top)) m))
	      ((> o 0) (begin (set! ko (if (= o 1) #t #f)) 
			      (get-empty) 
			      m)))))
    (::! (G-B2 G) (G-B G)) (:i! H) (get-empty)
    (do ((q 0 0)) ((or (= c (* 3 NN)) 
		       (and (> c (+ 1 ms)) 
			    (= 0 (: H (- c 1))) (= 0 (: H (- c 2)))  )))
      (set! i 0) (:! H c (find-m)) (set! c (+ c 1)))    
    (set-G-c! G c) 
    G))  

(define (amaf G)
  (let* ((c (G-c G)) (ms (G-ms G)) (H (G-H G)) 
	 (s (norm-score (score (G-B G)) ms)) (m 0)) 
    (set-G-score! G (+ (G-score G) s)) 
    (set-G-nodes! G (+ (G-nodes G) (- c ms)))
    (do ((i ms (+ i 2))) ((>= i c) G) 
      (set! m (: H i)) 
      (do ((j ms (+ j 1))) ((or (= m (: H j)) ) 
			    (when (= j i) 
				  (:! (G-WINS G) m (+ (: (G-WINS G) m) s)) 
				  (:! (G-HITS G) m (+ (: (G-HITS G) m) 1))))))))

(define (best-move G H)
  (do ((i 0 (+ i 1))) ((= i NN)) 
    (let ((m (: P i))) 
      (when (not (and (> (: (G-HITS G) m) 0) 
		      (legal? (::! (G-B2 G) (G-B G)) H (G-ms G) m))) 
	    (:! (G-WINS G) m -1) 
	    (:! (G-HITS G) m 1))))
  (:max (:/ (G-WINS G) (G-HITS G))))

(define (playouts l G) (if (= l 0) G (playouts (- l 1) (amaf (playout G)))))
(define (mc L H) (init-G H) (set! seed 1) (best-move (playouts L G) H))

;------------------------------------------------------------

;(display (mc L (::! HIS (:= (:l HIS))))) 
;(display HIS)

(define args 0)
(define HIS 0)
(define res 0)
(set! args (list->vector (map (lambda (n) (inexact->exact (truncate (string->number n)))) (vector->list argv))))

(init);(go)
(set! G (make-G (:= NNN 4) 0 0 0 (:= (* 4 NNN) 0) (:= NNN 0) (:= NNN 0) 0 0))

(set! HIS (if (>= (:l args) 3) (vector-drop 2 args) (:= 0))) ;(:= (:l args))
;(do ((i 2 (+ i 1))) ((= i (- (:l args) 5))) (:! HIS (- i 1) (: args i)))
;(display args) (newline)
;(display HIS) (newline)
;(display (:l HIS)) (newline)
;(display L) (newline)

(set! res (mc L HIS))
;(newline) (display "<") (display res) (display ">") (newline)
;
(display res) 
(newline)